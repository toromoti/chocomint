#!/usr/bin/env bash
# vim: ft=sh

source "${_CHM_LIBEXEC}/chocomint-lib/outputs"

_chm_aggregate_results() {
  # $1 exitstatus
  ((_CHM_CMD_COUNT++))
  local _chm_cmd_failure=false
  local _chm_left
  local _chm_mid
  local _chm_right

  for _chm_line in "${_CHM_TESTLINE_LIST[@]}"
  do
    for _chm_i in $(seq 0 "${_CHM_DATABASE[${_CHM_FULLPATH},${_chm_line},max_test_index]}")
    do
      ((_CHM_TEST_COUNT++))
      _chm_left="$(eval echo "${_CHM_DATABASE[${_CHM_FULLPATH},${_chm_line},${_chm_i},left]}")"
      _chm_mid="$(eval echo "${_CHM_DATABASE[${_CHM_FULLPATH},${_chm_line},${_chm_i},mid]}")"
      _chm_right="$(eval echo "${_CHM_DATABASE[${_CHM_FULLPATH},${_chm_line},${_chm_i},right]}")"

      if "${_CHM_LIBEXEC}/chocomint-main-judge" \
        "${_chm_left}" "${_chm_mid}" "${_chm_right}" "${1}" \
        "${_CHM_CMD_OUT_FILE}" "${_CHM_CMD_ERR_FILE}"
      then
        ((_CHM_TEST_SUCCESS++))
        _chm_outputs.ok "${_chm_left}" "${_chm_mid}" "${_chm_right}" "${1}"
      else
        exitcode=$?
        if [ $exitcode -eq 1 ]; then
          ((_CHM_TEST_FAILURE++))
          _chm_outputs.ng "${_chm_left}" "${_chm_mid}" "${_chm_right}" "${1}"
          _chm_cmd_failure=true
          _CHM_FAILURE=true
        else
          exit $exitcode
        fi
      fi
    done
  done

  $_chm_cmd_failure || ((_CHM_CMD_SUCCESS++))

  _chm_outputs.stdout
  _chm_outputs.stderr
  _chm_outputs.print "${_CHM_TIME_RESULT} seconds. "
  _chm_outputs.echo
}


_chm_prepare_execution-search_continuous_testline() {
  # $1 line number
  local _chm_ln="${1}"
  local _chm_i=1
  while [ "${_CHM_TEST_POSITION[${_CHM_FULLPATH},$(( _chm_ln + _chm_i ))]-}" = 'NL' ]
  do
    _CHM_TESTLINE_LIST=("${_CHM_TESTLINE_LIST[@]}" "$(( _chm_ln + _chm_i ))")
    ((_chm_i++))
  done
}


_chm_prepare_execution() {
  # $1 line number
  if [ "${_CHM_TEST_POSITION[${_CHM_FULLPATH},${1}]-}" = "EOL" ]; then
    _CHM_TEST_EXIST=true
    _CHM_TESTLINE_LIST=("${1}")
    _chm_prepare_execution-search_continuous_testline "${1}"
  elif [ "${_CHM_TEST_POSITION[${_CHM_FULLPATH},$((${1}+1))]-}" = "NL" ]; then
    _CHM_TEST_EXIST=true
    _CHM_TESTLINE_LIST=()
    _chm_prepare_execution-search_continuous_testline "${1}"
  else
    _CHM_TEST_EXIST=false
  fi

  ${_CHM_TEST_EXIST} && {
    : > "${_CHM_CMD_OUT_FILE}"
    : > "${_CHM_CMD_ERR_FILE}"
    _chm_outputs.command "==> L${1}: " "${2}"
  }
}


_chm_trap() {
  # $1 line number
  # $2 source path
  $_CHM_DEBUG && {
    echo "LINENO: $1" >&3
    echo "BASH_SOURCE: $2" >&3
    echo "#FUNCNAME[*]: $3" >&3
    echo "FUNCNAME: $4" >&3
  }
  local _chm_prev_stat="$?"

  [ "${_CHM_TIME_START}" ] && {
    _CHM_TIME_RESULT=$(( $(date +%s) - _CHM_TIME_START ))
  }

  if [ "${3}" = "${_CHM_TARGETFILE_STACK_LEVEL}" ]; then
    ${_CHM_TEST_EXIST} && _chm_aggregate_results "${_chm_prev_stat}"
    _chm_prepare_execution "${1}" "${BASH_COMMAND}"
  fi

  _CHM_TIME_START=$(date +%s)
}


_chm_run_test() {
  exec 3>&1 4>&2 1> "${_CHM_CMD_OUT_FILE}" 2> "${_CHM_CMD_ERR_FILE}"
  set -T; trap '_chm_trap "${LINENO}" "${BASH_SOURCE}" "${#FUNCNAME[*]}" "`declare -p FUNCNAME`"' DEBUG
  _CHM_TARGETFILE_STACK_LEVEL=$(( ${#FUNCNAME[*]} + 1 ))
  source "${1}"; local exitstat=$?
  # if the last command has a test, execute the analysis here.
  trap DEBUG; set +T
  ${_CHM_TEST_EXIST} && _chm_aggregate_results "${exitstat}"
  exec 1>&3- 2>&4-
}


_chm_main() {
  source "${_CHM_TEST_POSITION_FILE}"
  source "${_CHM_DATABASE_FILE}"

  _CHM_TEST_EXIST=false
  _CHM_TIME_START=''
  _CHM_FULLPATH="$1"

  _chm_run_test "$_CHM_FULLPATH"

  {
    declare -p _CHM_TEST_FAILURE
    declare -p _CHM_TEST_SUCCESS
    declare -p _CHM_TEST_COUNT
    declare -p _CHM_CMD_SUCCESS
    declare -p _CHM_CMD_COUNT
    declare -p _CHM_FAILURE
  } > "${_CHM_TEST_RESULTS_FILE}"
}

_chm_main "$1"
