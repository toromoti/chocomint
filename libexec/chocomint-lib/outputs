#!/bin/bash
# vim: ft=sh

_CHM_OK_STRING=${_CHM_OK_STRING:-'[success] '}
_CHM_NG_STRING=${_CHM_NG_STRING:-'[failure] '}

function _chm_.draw_line() {
  local _chm_cols=$($_CHM_TPUT cols)
  [ "$_chm_cols" ] || {
    _chm_cols=40
  }
  local _chm_line
  for (( _chm_i=0; _chm_i<_chm_cols; _chm_i++ ))
  do
    _chm_line="${_chm_line}${1}"
  done
  echo "${_chm_line}"
}

function _chm_outputs.section() {
  echo
  _chm_.draw_line "-"
  echo " ${1}"
  _chm_.draw_line "-"
}

###

function _chm_.echo() { echo "$@" >&3; }
function _chm_.print() { echo -n "$@" >&3; }
function _chm_.cat() { cat "$@" >&3; }
function _chm_.tput() { $_CHM_TPUT "$@" >&3; }

function _chm_outputs.ok() { _chm_.judgeout "2" "$_CHM_OK_STRING" "$@"; }
function _chm_outputs.ng() { _chm_.judgeout "1" "$_CHM_NG_STRING" "$@"; }

function _chm_outputs.title() {
  _chm_.draw_line "+"
  echo " $* "
  _chm_.draw_line "+"
}


function _chm_.tprint() {
  while [ "$1" != "--" ]
  do
    case $1 in
      [0-7] )
        _chm_.tput setaf "$1"
        ;;
      'bold' )
        _chm_.tput bold
        ;;
    esac
    shift
  done
  _chm_.print "${*:2}$($_CHM_TPUT sgr0)"
}


function _chm_.judgeout.output_rsc() {
  case $1 in
    '::' )
      case $2 in
        'None' )
          _chm_.echo "$3 should be nothing"
          ;;
      esac
      ;;
    ':' )
      _chm_.print "fixed-strings '"
      _chm_.tprint "$_chm_opt_tput" -- "$2"
      _chm_.echo "' should match $3"
      ;;
    '!:' )
      _chm_.print "fixed-strings '"
      _chm_.tprint "$_chm_opt_tput" -- "$2"
      _chm_.echo "' should NOT match $3"
      ;;
    ':~' )
      _chm_.print "extended-regexp '"
      _chm_.tprint "$_chm_opt_tput" -- "$2"
      _chm_.echo "' should match $3"
      ;;
    '!:~' )
      _chm_.print "extended-regexp '"
      _chm_.tprint "$_chm_opt_tput" -- "$2"
      _chm_.echo "' should NOT match $3"
      ;;
  esac
}


function _chm_.judgeout() {
  # $1 label tput color
  # $2 label string
  # $3 left
  # $4 mid
  # $5 right
  # $6 exitstat
  local _chm_opt_tput="5"
  _chm_.tprint "$1" -- "$2" # 'ok' or 'ng'
  case $3 in
    'status' )
      case $4 in
        ':' )
          _chm_.print "status "
          _chm_.tprint "$_chm_opt_tput" -- "$6"
          _chm_.print " should be "
          _chm_.tprint "$_chm_opt_tput" -- "$5"
          _chm_.echo
          ;;
        '!:' )
          _chm_.print "status "
          _chm_.tprint "$_chm_opt_tput" -- "$6"
          _chm_.print " should NOT be "
          _chm_.tprint "$_chm_opt_tput" -- "$5"
          _chm_.echo
          ;;
      esac
      ;;
    'output' )
      _chm_.judgeout.output_rsc "$4" "$5" "outputs"
      ;;
    'stdout' )
      _chm_.judgeout.output_rsc "$4" "$5" "STDOUT"
      ;;
    'stderr' )
      _chm_.judgeout.output_rsc "$4" "$5" "STDERR"
      ;;
    * ) # judge variables
      case $4 in
        '=' )
          _chm_.print "value '"
          _chm_.tprint "$_chm_opt_tput" -- "$3"
          _chm_.print "' should be '"
          _chm_.tprint "$_chm_opt_tput" -- "$5"
          _chm_.echo "'"
          ;;
        '!=' )
          _chm_.print "value '"
          _chm_.tprint "$_chm_opt_tput" -- "$3"
          _chm_.print "' should NOT be '"
          _chm_.tprint "$_chm_opt_tput" -- "$5"
          _chm_.echo "'"
          ;;
        '=~' )
          _chm_.print "value '"
          _chm_.tprint "$_chm_opt_tput" -- "$3"
          _chm_.print "' should match extended-regexp '"
          _chm_.tprint "$_chm_opt_tput" -- "$5"
          _chm_.echo "'"
          ;;
        '!=~' )
          _chm_.print "value '"
          _chm_.tprint "$_chm_opt_tput" -- "$3"
          _chm_.print "' should NOT match extended-regexp '"
          _chm_.tprint "$_chm_opt_tput" -- "$5"
          _chm_.echo "'"
          ;;
      esac
      ;;
  esac
}


function _chm_.stdout() {
  #_chm_.tprint bold -- '>>> STDOUT BEGIN'
  #_chm_.echo
  sed 's/^/STDOUT: /' "$_CHM_CMD_OUT" >&3
  _chm_.tput sgr0 # for reset previous output attributes
  #_chm_.tprint bold -- '<<< STDOUT END'
  #_chm_.echo
}


function _chm_.stderr() {
  #_chm_.tprint bold -- '>>> STDERR BEGIN'
  #_chm_.echo
  #_chm_.cat $_CHM_CMD_ERR
  sed 's/^/STDERR: /' "$_CHM_CMD_ERR" >&3
  _chm_.tput sgr0 # for reset previous output attributes
  #_chm_.tprint bold -- '<<< STDERR END'
  #_chm_.echo
}


function _chm_outputs.stdouterr() {
  _chm_.stdout
  _chm_.stderr
  $_CHM_BC_COMMAND_EXIST &&
    _chm_.print "${1} seconds. "
  _chm_.echo
}


function _chm_outputs.overall_results() {
  echo
  $_CHM_TPUT bold
  if [ "$1" -eq 0 ]; then
    echo "$($_CHM_TPUT setaf 2)$3 tests, $5 commands all succeeded.$($_CHM_TPUT sgr0)"
  else
    echo "$($_CHM_TPUT setaf 1)$1 tests failed.$($_CHM_TPUT sgr0)"
    $_CHM_TPUT bold
    echo "$($_CHM_TPUT setaf 1)$2/$3 tests, $4/$5 commands succeeded.$($_CHM_TPUT sgr0)"
  fi
}


function _chm_outputs.command() {
  _chm_.tprint 3 -- "${1}"
  echo "${2}" | sed s/^/$($_CHM_TPUT sgr0)/ | sed s/$/$($_CHM_TPUT sgr0)/ >&3
}
