#!/usr/bin/env bash

_CHM_NAME='chocomint.sh'
_CHM_VERSION='0.3.6-dev'

export _CHM_CMD_OUT="/tmp/_chm_command_stdout.$$.log"
export _CHM_CMD_ERR="/tmp/_chm_command_stderr.$$.log"

export _CHM_TEST_POSITION_FILE="/tmp/_chm_test_pos.$$"
export _CHM_DB_FILE="/tmp/_chm_test_db.$$"

export _CHM_LIBEXEC="$(dirname -- "$(readlink -f -- "${BASH_SOURCE:-$0}")")"
source "${_CHM_LIBEXEC}/chocomint-lib/outputs"

export _CHM_TEST_RESULTS_FILE="/tmp/_chm_test_results.$$"
# variables in _CHM_TEST_RESULTS_FILE
export _CHM_TEST_FAILURE=0
export _CHM_TEST_SUCCESS=0
export _CHM_TEST_COUNT=0
export _CHM_CMD_SUCCESS=0
export _CHM_CMD_COUNT=0
export _CHM_FAILURE=false


_tput() { $_CHM_TPUT "$@"; }

_chm_system_check() {
  #
  # "tput" exist check
  #
  [ ! -t 1 ] && export _CHM_TPUT="true" && return

  if type tput > /dev/null 2>&1
  then
    export _CHM_TPUT="tput"
  else
    echo "WARN: \"tput\" command is not found"
    echo "WARN: run without coloring"
    echo
    export _CHM_TPUT="true"
  fi
}


_chm_file_check() {
  # $1 target fullpath
  [ -f "$1" ] || {
    echo "No such a file: $1" 1>&2
    exit 3
  }
}

_chm_main() {
  [ "$1" ] || {
    echo "${_CHM_NAME}: no input file" 1>&2
    exit 2
  }

  _chm_system_check

  _chm_outputs.title "${_CHM_NAME} ${_CHM_VERSION}"

  for i in "$@"
  do
    local fullpath="$(readlink -f -- "${i}")"
    _chm_file_check "${fullpath}"
    local _chm_fullpath_list=("${_chm_fullpath_list[@]}" "${fullpath}")
  done

  "${_CHM_LIBEXEC}/chocomint-parse" "${_chm_fullpath_list[@]}" || exit $?
  "${_CHM_LIBEXEC}/chocomint-main"  "${_chm_fullpath_list[@]}" || exit $?

  source ${_CHM_TEST_RESULTS_FILE}
  rm ${_CHM_TEST_RESULTS_FILE}
  rm ${_CHM_TEST_POSITION_FILE}
  rm ${_CHM_DB_FILE}

  _chm_outputs.overall_results \
    "${_CHM_TEST_FAILURE}"     \
    "${_CHM_TEST_SUCCESS}"     \
    "${_CHM_TEST_COUNT}"       \
    "${_CHM_CMD_SUCCESS}"      \
    "${_CHM_CMD_COUNT}"

  ${_CHM_FAILURE} && return 1 || return 0
}

_chm_main "$@"
