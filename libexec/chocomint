#!/usr/bin/env bash

NAME='chocomint.sh'
VERSION='0.3.7-dev'

export _CHM_CMD_OUT_FILE=$(mktemp "/tmp/_chm_command_stdout.tmp.$$.XXXXXX")
export _CHM_CMD_ERR_FILE=$(mktemp "/tmp/_chm_command_stderr.tmp.$$.XXXXXX")

export _CHM_TEST_POSITION_FILE=$(mktemp "/tmp/_chm_test_position.tmp.$$.XXXXXX")
export _CHM_DATABASE_FILE=$(mktemp "/tmp/_chm_database.tmp.$$.XXXXXX")

export _CHM_TEST_RESULTS_FILE=$(mktemp "/tmp/_chm_test_results.tmp.$$.XXXXXX")
# variables in _CHM_TEST_RESULTS_FILE
export _CHM_TEST_FAILURE=0
export _CHM_TEST_SUCCESS=0
export _CHM_TEST_COUNT=0
export _CHM_CMD_SUCCESS=0
export _CHM_CMD_COUNT=0
export _CHM_FAILURE=false

export _CHM_LIBEXEC="$(dirname -- "$(readlink -f -- "${BASH_SOURCE:-$0}")")"

source "${_CHM_LIBEXEC}/chocomint-lib/outputs"

for opt in "$@"
do
  case "$opt" in
    '--ignore-parse-error' )
      IGNORE_PARSE_ERROR=true
      shift 1
      ;;
  esac
done

system_check() {
  #
  # "tput" exist check
  #
  [ ! -t 1 ] && export _CHM_TPUT="true" && return

  if type tput > /dev/null 2>&1
  then
    export _CHM_TPUT="tput"
  else
    echo "WARN: \"tput\" command is not found"
    echo "WARN: run without coloring"
    echo
    export _CHM_TPUT="true"
  fi
}


file_check() {
  # $1 target fullpath
  [ -d "$1" ] && {
    echo "WARN: \"$1\" is a directory" 1>&2
    return 1
  }
  [ -f "$1" ] || {
    echo "No such a file: \"$1\"" 1>&2
    exit 3
  }
  return 0
}


parse() {
  "${_CHM_LIBEXEC}/chocomint-parse" "$@" || {
    exitcode=$?
    case $exitcode in
      '1' )
        :
        ;;
      * )
        echo "chocomint-parse: Unknown Error (code $exitcode)"
        ;;
    esac
    [ "$IGNORE_PARSE_ERROR" ] || exit $exitcode
  }
}


run() {
  "${_CHM_LIBEXEC}/chocomint-main" "$@" || {
    exitcode=$?
    case $exitcode in
      '21' )
        :
        ;;
      * )
        echo "chocomint-main: Unknown Error (code $exitcode)"
        ;;
    esac
    exit $exitcode
  }
}


main() {
  [ "$1" ] || {
    echo "${NAME}: no input file" 1>&2
    exit 2
  }

  system_check

  _chm_outputs.title "${NAME} ${VERSION}"

  for i in "$@"
  do
    local fullpath="$(readlink -f -- "${i}")"
    file_check "${fullpath}"
    [ $? -eq 0 ] && {
      local fullpath_list=("${fullpath_list[@]}" "${fullpath}")
    }
  done
  [ "${fullpath_list[*]}" ] || exit 3

  parse "${fullpath_list[@]}"
  run "${fullpath_list[@]}"

  source ${_CHM_TEST_RESULTS_FILE}

  _chm_outputs.overall_results \
    "${_CHM_TEST_FAILURE}"     \
    "${_CHM_TEST_SUCCESS}"     \
    "${_CHM_TEST_COUNT}"       \
    "${_CHM_CMD_SUCCESS}"      \
    "${_CHM_CMD_COUNT}"

  ${_CHM_FAILURE} && return 1 || return 0
}

trap "rm \"${_CHM_CMD_OUT_FILE}\" \
         \"${_CHM_CMD_ERR_FILE}\" \
         \"${_CHM_TEST_RESULTS_FILE}\" \
         \"${_CHM_TEST_POSITION_FILE}\" \
         \"${_CHM_DATABASE_FILE}\" > /dev/null 2>&1" EXIT

main "$@"
