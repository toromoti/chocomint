#!/usr/bin/env bash

_CHOCOMINT_NAME='chocomint.sh'
_CHOCOMINT_VERSION='0.1.0-rc2'

CHOCOMINT_LIBEXEC="$(dirname -- "$(readlink -f -- "${BASH_SOURCE:-$0}")")"
CHOCOMINT_TARGET_FULLPATH="$(readlink -f -- "$1")"

CHOCOMINT_CMD_OUT="/tmp/_chocomint_command_stdout.$$.log"
CHOCOMINT_CMD_ERR="/tmp/_chocomint_command_stderr.$$.log"

CHOCOMINT_CMD_SUCCESS=0
_CHOCOMINT_CMD_COUNT=0
_CHOCOMINT_TEST_FAILURE=0
_CHOCOMINT_TEST_SUCCESS=0
_CHOCOMINT_TEST_COUNT=0
_CHOCOMINT_FAILURE=false
_CHOCOMINT_TEST_EXIST=false

source $CHOCOMINT_LIBEXEC/lib/outputs
source $CHOCOMINT_LIBEXEC/lib/utils

_chocomint_aggregate_results() {
  # $1 exitstatus
  local _chocomint_cmd_failure=false
  local _chocomint_left _chocomint_right
  ((_CHOCOMINT_CMD_COUNT++))

  for _chocomint_i in $(seq 0 ${CHOCOMINT_DB[$CHOCOMINT_TESTLINE,max]})
  do
    _chocomint_left="$(eval echo "${CHOCOMINT_DB[$CHOCOMINT_TESTLINE,$_chocomint_i,left]}")"
    _chocomint_right="$(eval echo "${CHOCOMINT_DB[$CHOCOMINT_TESTLINE,$_chocomint_i,right]}")"
    ((_CHOCOMINT_TEST_COUNT++))

    if $CHOCOMINT_LIBEXEC/judge \
        "$_chocomint_left" \
        "${CHOCOMINT_DB[$CHOCOMINT_TESTLINE,$_chocomint_i,mid]}" \
        "$_chocomint_right" \
        "$1" \
        "$CHOCOMINT_CMD_OUT" \
        "$CHOCOMINT_CMD_ERR"
    then
      chocomint_outputs.ok \
        "$_chocomint_left" \
        "${CHOCOMINT_DB[$CHOCOMINT_TESTLINE,$_chocomint_i,mid]}" \
        "$_chocomint_right" \
        "$1"
      ((_CHOCOMINT_TEST_SUCCESS++))
    else
      chocomint_utils.error $?
      chocomint_outputs.ng \
        "$_chocomint_left" \
        "${CHOCOMINT_DB[$CHOCOMINT_TESTLINE,$_chocomint_i,mid]}" \
        "$_chocomint_right" \
        "$1"
      _chocomint_cmd_failure=true
      _CHOCOMINT_FAILURE=true
      ((_CHOCOMINT_TEST_FAILURE++))
    fi
  done

  chocomint_outputs.stdouterr "$_chocomint_cmd_failure"
}


_chocomint_prepare_execution() {
  _CHOCOMINT_LINENO_CACHE="$1"

  if [ "${CHOCOMINT_TEST_POSITION[$1]}" = "EOL" ]; then
    _CHOCOMINT_TEST_EXIST=true
    CHOCOMINT_TESTLINE="$1"
  elif [ "${CHOCOMINT_TEST_POSITION[$(($1+1))]}" = "NL" ]; then
    _CHOCOMINT_TEST_EXIST=true
    CHOCOMINT_TESTLINE="$(($1+1))"
  else
    _CHOCOMINT_TEST_EXIST=false
  fi

  $_CHOCOMINT_TEST_EXIST && {
    : > $CHOCOMINT_CMD_OUT
    : > $CHOCOMINT_CMD_ERR
    chocomint_outputs.command "$2"
  }
}


_chocomint_trap() {
  # $1 line number
  # $2 source path
  local _chocomint_prev_stat="$?"

  [ "$_CHOCOMINT_TIME_START" ] && {
    CHOCOMINT_TIME_RESULT=$(echo "$(date +%s.%N) - $_CHOCOMINT_TIME_START" | bc | sed -e 's/^\./0\./')
  }

  if [ "$2" = "$CHOCOMINT_TARGET_FULLPATH" ]; then
    $_CHOCOMINT_TEST_EXIST &&
      _chocomint_aggregate_results "$_chocomint_prev_stat"
    _chocomint_prepare_execution "$1" "$BASH_COMMAND"
  fi

  _CHOCOMINT_TIME_START=$(date +%s.%N)
}


_chocomint_run_test() {
  exec 3>&1 4>&2 1> $CHOCOMINT_CMD_OUT 2> $CHOCOMINT_CMD_ERR
  set -T; trap '_chocomint_trap "$LINENO" "$BASH_SOURCE"' DEBUG
  source "$1"; local exitstat=$?
  # if the last command has a test, execute the analysis here.
  trap DEBUG; set +T
  $_CHOCOMINT_TEST_EXIST &&
    _chocomint_aggregate_results "$exitstat"
  exec 1>&3- 2>&4-
  rm "$CHOCOMINT_CMD_OUT" "$CHOCOMINT_CMD_ERR"
}


_chocomint_main() {
  [ "$CHOCOMINT_TARGET_FULLPATH" ] || {
    echo "No target file"
    exit 2
  }

  [ -f "$CHOCOMINT_TARGET_FULLPATH" ] || {
    echo "No such a file: $CHOCOMINT_TARGET_FULLPATH"
    exit 3
  }

  echo 'Parsing tests...'
  source <($CHOCOMINT_LIBEXEC/parse "$1" || cat /dev/null) # local variable

  chocomint_outputs.title "$_CHOCOMINT_NAME $_CHOCOMINT_VERSION"

  _chocomint_run_test "$1"

  chocomint_outputs.overall_results \
    "$_CHOCOMINT_TEST_FAILURE" \
    "$_CHOCOMINT_TEST_SUCCESS" \
    "$_CHOCOMINT_TEST_COUNT" \
    "$CHOCOMINT_CMD_SUCCESS" \
    "$_CHOCOMINT_CMD_COUNT"

  $_CHOCOMINT_FAILURE && return 1
  return 0
}

_chocomint_main "$CHOCOMINT_TARGET_FULLPATH"
