#!/usr/bin/env bash

#set -x # debug mode
#set -n # syntax check
ROOT="$(dirname -- "$(readlink -f -- "${BASH_SOURCE:-$0}")")"/..
echo $ROOT

declare -a DEF_COMMENT_LINENUM   # テストコメントがある行番号
declare -a TEST_COMMENT_LINENUM  # テストコメントがある行番号
declare -a TEST_COMMENT_STYLE    # "NL" or "EOL"
declare -a TEST_COMMENT      # 行番号 -> テストコメントの内容
declare -i LINENUM=1
declare TEST_COMMENT
declare PARSE_METHOD="parse_nl"

parse_def_comments() {
  case $1 in
    "" )
      DEF_COMMENT_LINENUM+=( "$LINENUM" )
      PARSE_METHOD="parse_nl"
      LINENUM+=1
      DEF_COMMENT=""
      ;;
    * )
      DEF_COMMENT="$DEF_COMMENT$1"
      ;;
  esac
}

parse_test_comments() {
  case $1 in
    ":" )
      PARSE_METHOD="parse_def_comments"
      ;;
    "" )
      TEST_COMMENT_LINENUM+=( "$LINENUM" )
      TEST_COMMENT_STYLE[LINENUM]="$COMMENT_IN"
      TEST_COMMENT[LINENUM]="$TEST_COMMENT"
      PARSE_METHOD="parse_nl"
      LINENUM+=1
      TEST_COMMENT=""
      ;;
    * )
      TEST_COMMENT="$TEST_COMMENT$1"
      ;;
  esac
}

parse_hash() {
  case $1 in
    ":" )
      PARSE_METHOD="parse_test_comments"
      ;;
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_nl"
      ;;
    * )
      PARSE_METHOD="parse_main"
      ;;
  esac
}

parse_dq_bs() {
  case $1 in
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_dq"
      ;;
    * )
      PARSE_METHOD="parse_dq"
      ;;
  esac
}

parse_dq() {
  case $1 in
    "\\" )
      PARSE_METHOD="parse_dq_bs"
      ;;
    '"' )
      PARSE_METHOD="parse_main"
      ;;
    "" )
      LINENUM+=1
      ;;
    * )
      :
      ;;
  esac
}

parse_sq_bs() {
  case $1 in
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_sq"
      ;;
    * )
      PARSE_METHOD="parse_sq"
      ;;
  esac
}

parse_sq() {
  case $1 in
    "\\" )
      PARSE_METHOD="parse_sq_bs"
      ;;
    "'" )
      PARSE_METHOD="parse_main"
      ;;
    "" )
      LINENUM+=1
      ;;
    * )
      :
      ;;
  esac
}

parse_bs() {
  case $1 in
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_main"
      ;;
    * )
      PARSE_METHOD="parse_main"
      ;;
  esac
}

parse_main() {
  case $1 in
    "#" )
      PARSE_METHOD="parse_hash"
      COMMENT_IN="EOL"
      ;;
    "\\" )
      PARSE_METHOD="parse_bs"
      ;;
    "'" )
      PARSE_METHOD="parse_sq"
      ;;
    '"' )
      PARSE_METHOD="parse_dq"
      ;;
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_nl"
      ;;
    * )
      ;;
  esac
}

parse_nl_space() {
  case $1 in
    "#" )
      PARSE_METHOD="parse_hash"
      COMMENT_IN="NL"
      ;;
    " "|"\t" )
      PARSE_METHOD="parse_nl_space"
      ;;
    "\\" )
      PARSE_METHOD="parse_bs"
      ;;
    "'" )
      PARSE_METHOD="parse_sq"
      ;;
    '"' )
      PARSE_METHOD="parse_dq"
      ;;
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_nl"
      ;;
    * )
      PARSE_METHOD="parse_main"
      ;;
  esac
}

parse_nl() {
  case $1 in
    "#" )
      PARSE_METHOD="parse_hash"
      COMMENT_IN="NL"
      ;;
    " "|"\t" )
      PARSE_METHOD="parse_nl_space"
      ;;
    "\\" )
      PARSE_METHOD="parse_bs"
      ;;
    "'" )
      PARSE_METHOD="parse_sq"
      ;;
    '"' )
      PARSE_METHOD="parse_dq"
      ;;
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_nl"
      ;;
    * )
      PARSE_METHOD="parse_main"
      ;;
  esac
}

main() {
  local file=$1
  local line
  local char

  while IFS= read -r line; do
    while IFS= read -r -n 1 char; do
      $PARSE_METHOD "$char"
    done < <(echo $line)
  done < $file
}

main "$@"

declare -p TEST_COMMENT
echo ------------
declare -p TEST_COMMENT_LINENUM
echo ------------
declare -p TEST_COMMENT_STYLE
echo ------------
declare -p BASH_SOURCE
echo ------------

declare -i EXEC_NUM=1

ruler() {
  [ "$TERM_COLS" ] || {
    local cols=`tput cols 2>&4`
    for ((i=0; i<$cols; i++))
    do
      TERM_COLS="$TERM_COLS""$1"
    done
  }
  echo "$TERM_COLS" >&3
}

screen_out() {
    local stdout=$(cat /tmp/_bashtf_command_stdout.$$.log)
    [ "$stdout" ] && {
      #tput setaf 2 >&3
      echo "[ stdout ]" >&3
      echo "$stdout" >&3
      #tput sgr0 >&3
      : > /tmp/_bashtf_command_stdout.$$.log
    }
    local errout=$(cat /tmp/_bashtf_command_stderr.$$.log)
    [ "$errout" ] && {
      echo "[ errout ]" >&3
      echo "$errout" >&3
      : > /tmp/_bashtf_command_stderr.$$.log
    }
}

catch_execution() {
  [ "$2" = "$TARGET_FULLPATH" ] && {
    screen_out

    tput bold >&3
    ruler "="
    printf "No.%0$((${#LINENUM}+1))d  L%0${#LINENUM}d\n" "$((EXEC_NUM++))" "$1" >&3
    echo "raw  : $BASH_COMMAND" >&3
    eval "echo \"eval : $BASH_COMMAND\" >&3"

    if [ "${TEST_COMMENT_STYLE[$1]}" = "EOL" ]; then
      echo -n "test : " >&3
      eval "echo \"${TEST_COMMENT[$1]}\" >&3"
    elif [ "${TEST_COMMENT_STYLE[$(($1+1))]}" = "NL" ]; then
      echo -n "test : " >&3
      eval "echo \"${TEST_COMMENT[$(($1+1))]}\" >&3"
    fi
    tput sgr0 >&3
  }
}

preprocess() {
  set -E
  set -T
  eval "exec 3>&1 4>&2 1> /tmp/_bashtf_command_stdout.$$.log 2> /tmp/_bashtf_command_stderr.$$.log"
  trap 'catch_execution "$LINENO" "$BASH_SOURCE"' DEBUG
}

postprocess() {
  screen_out
  trap DEBUG
  exec 1>&3- 2>&4-
  set +E
  set +T
}

runtest() {
  TARGET_FULLPATH="$(readlink -f -- "$1")"
  preprocess
  . "$TARGET_FULLPATH"
  postprocess
}

runtest $1
