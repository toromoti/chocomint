#!/usr/bin/env bash

_BASHTF_LIBEXEC_DIR="$(dirname -- "$(readlink -f -- "${BASH_SOURCE:-$0}")")"

_BASHTF_CMD_OUT="/tmp/_bashtf_command_stdout.$$.log"
_BASHTF_CMD_ERR="/tmp/_bashtf_command_stderr.$$.log"

_bashtf_judge() {
  # $1 left string
  # $2 middle string
  # $3 right string
  # $4 exit status
  # $5 stdout
  # $6 stderr
  case $2 in
    "=" )
      if [ "$1" = "$3" ]; then
        echo "$1" = "$3" "==> true"
      else
        echo "$1" = "$3" "==> false"
      fi
      ;;
    "!=" )
      if [ "$1" != "$3" ]; then
        echo "$1" != "$3" "==> true"
      else
        echo "$1" != "$3" "==> false"
      fi
      ;;
    ":" )
      case $1 in
        'status' )
          if [ "$4" = "$3" ]; then
            echo status:"$3" "==> true"
          else
            echo status:"$3" "==> false"
          fi
          ;;
        'match' )
          if \egrep -q "`eval echo "$3"`" "$_BASHTF_CMD_OUT"; then
            eval echo match:"$3" "==\> true"
          else
            eval echo match:"$3" "==\> false"
          fi
          ;;
      esac
      ;;
    "!:" )
      case $1 in
        'status' )
          if [ "$4" != "$3" ]; then
            echo status:"$3" "==> true"
          else
            echo status:"$3" "==> false"
          fi
          ;;
        'match' )
          if \egrep -q "`eval echo "$3"`" "$_BASHTF_CMD_OUT"; then
            eval echo match:"$3" "==\> false"
          else
            eval echo match:"$3" "==\> true"
          fi
          ;;
      esac
      ;;
  esac

  #[ "$match" ] && if echo "$_stdout" | \egrep "$match" > /dev/null 2>&1; then
  #  result_list+=( true )
  #else
  #  result_list+=( false )
  #fi

  #[ "$not_match" ] && if echo "$_stdout" | \egrep "$not_match" > /dev/null 2>&1; then
  #  result_list+=( false )
  #else
  #  result_list+=( true )
  #fi

  #echo "===> ${result_list[@]}"
  #_bashtf_indent_echo 5 "$_BASHTF_CMD_EVAL_CACHE"
}


_bashtf_analyze_test_results() {
  # $1 exitstatus
  # $2 stdout
  # $3 stderr
  for _bashtf_i in `seq 0 ${_BASHTF_HASH[$_BASHTF_TESTLINE,max]}`
  do
    _bashtf_judge \
      "${_BASHTF_HASH[$_BASHTF_TESTLINE,$_bashtf_i,left]}" \
      "${_BASHTF_HASH[$_BASHTF_TESTLINE,$_bashtf_i,mid]}" \
      "${_BASHTF_HASH[$_BASHTF_TESTLINE,$_bashtf_i,right]}" \
      "$1" \
      "$2" \
      "$3"
  done
}


_bashtf_cache_execution_data() {
  _BASHTF_LINENO_CACHE="$1"
  _BASHTF_CMD_CACHE="$2"
  _BASHTF_CMD_EVAL_CACHE=$(eval "echo -n \"$2\"")

  if [ "${_BASHTF_TEST_COMMENT_STYLE[$1]}" = "EOL" ]; then
    _BASHTF_TESTLINE="$1"
    _BASHTF_TESTEXIST=true
  elif [ "${_BASHTF_TEST_COMMENT_STYLE[$(($1+1))]}" = "NL" ]; then
    _BASHTF_TESTLINE=$(($1+1))
    _BASHTF_TESTEXIST=true
  else
    _BASHTF_TESTEXIST=false
  fi
}


_bashtf_trap() {
  # $1 line number
  # $2 source path
  local _bashtf_prev_stat="$?"

  if [ "$2" = "$TARGET_FULLPATH" ]; then
    _bashtf_redirect_switch_off
    $_BASHTF_TESTEXIST &&
      _bashtf_analyze_test_results \
        "$_bashtf_prev_stat" \
        "$(<$_BASHTF_CMD_OUT)" \
        "$(<$_BASHTF_CMD_ERR)"
    _bashtf_cache_execution_data "$1" "$BASH_COMMAND"
    _bashtf_redirect_switch_on
  fi
}


_bashtf_redirect_switch_on() {
  exec 3>&1 4>&2 1> $_BASHTF_CMD_OUT 2> $_BASHTF_CMD_ERR
}


_bashtf_redirect_switch_off() {
  exec 1>&3- 2>&4-
}


_bashtf_test_process() {
  _BASHTF_TESTEXIST=false
  _bashtf_redirect_switch_on
  source "$1"
  _bashtf_redirect_switch_off

  _bashtf_analyze_test_results \
    "$?" \
    "$(<$_BASHTF_CMD_OUT)" \
    "$(<$_BASHTF_CMD_ERR)"

  rm "$_BASHTF_CMD_OUT" "$_BASHTF_CMD_ERR"
}


_bashtf_main() {
  TARGET_FULLPATH="$(readlink -f -- "$1")"
  eval "`$_BASHTF_LIBEXEC_DIR/parse $TARGET_FULLPATH`"
  source $_BASHTF_LIBEXEC_DIR/outputs

  set -T; trap '_bashtf_trap "$LINENO" "$BASH_SOURCE"' DEBUG

  _bashtf_test_process "$TARGET_FULLPATH"

  trap DEBUG; set +T
}


_bashtf_main "$1"
