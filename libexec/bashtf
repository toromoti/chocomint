#!/usr/bin/env bash

declare _BASHTF_LIBEXEC_DIR="$(dirname -- "$(readlink -f -- "${BASH_SOURCE:-$0}")")"

declare -a DEF_COMMENT_LINENUM   # テストコメントがある行番号
declare -a TEST_COMMENT_LINENUM  # テストコメントがある行番号
declare -a _BASHTF_TEST_COMMENT_STYLE    # "NL" or "EOL"
declare -a TEST_COMMENT      # 行番号 -> テストコメントの内容
declare -i LINENUM=1
declare TEST_COMMENT
declare _BASHTF_TEST_MARKER=":"
declare PARSE_METHOD="parse_nl"

declare _BASHTF_CMD_OUT="/tmp/_bashtf_command_stdout.$$.log"
declare _BASHTF_CMD_ERR="/tmp/_bashtf_command_stderr.$$.log"

parse_def_comments() {
  case $1 in
    "" )
      DEF_COMMENT_LINENUM+=( "$LINENUM" )
      PARSE_METHOD="parse_nl"
      LINENUM+=1
      DEF_COMMENT=""
      ;;
    * )
      DEF_COMMENT="$DEF_COMMENT$1"
      ;;
  esac
}

parse_test_comments() {
  case $1 in
    "$_BASHTF_TEST_MARKER" )
      PARSE_METHOD="parse_def_comments"
      ;;
    "" )
      TEST_COMMENT_LINENUM+=( "$LINENUM" )
      _BASHTF_TEST_COMMENT_STYLE[LINENUM]="$COMMENT_IN"
      TEST_COMMENT[LINENUM]="$TEST_COMMENT"
      PARSE_METHOD="parse_nl"
      LINENUM+=1
      TEST_COMMENT=""
      ;;
    * )
      TEST_COMMENT="$TEST_COMMENT$1"
      ;;
  esac
}

parse_hash() {
  case $1 in
    "$_BASHTF_TEST_MARKER" )
      PARSE_METHOD="parse_test_comments"
      ;;
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_nl"
      ;;
    * )
      PARSE_METHOD="parse_main"
      ;;
  esac
}

parse_dq_bs() {
  case $1 in
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_dq"
      ;;
    * )
      PARSE_METHOD="parse_dq"
      ;;
  esac
}

parse_dq() {
  case $1 in
    "\\" )
      PARSE_METHOD="parse_dq_bs"
      ;;
    '"' )
      PARSE_METHOD="parse_main"
      ;;
    "" )
      LINENUM+=1
      ;;
    * )
      :
      ;;
  esac
}

parse_sq_bs() {
  case $1 in
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_sq"
      ;;
    * )
      PARSE_METHOD="parse_sq"
      ;;
  esac
}

parse_sq() {
  case $1 in
    "\\" )
      PARSE_METHOD="parse_sq_bs"
      ;;
    "'" )
      PARSE_METHOD="parse_main"
      ;;
    "" )
      LINENUM+=1
      ;;
    * )
      :
      ;;
  esac
}

parse_bs() {
  case $1 in
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_main"
      ;;
    * )
      PARSE_METHOD="parse_main"
      ;;
  esac
}

parse_main() {
  case $1 in
    "#" )
      PARSE_METHOD="parse_hash"
      COMMENT_IN="EOL"
      ;;
    "\\" )
      PARSE_METHOD="parse_bs"
      ;;
    "'" )
      PARSE_METHOD="parse_sq"
      ;;
    '"' )
      PARSE_METHOD="parse_dq"
      ;;
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_nl"
      ;;
    * )
      ;;
  esac
}

parse_nl_space() {
  case $1 in
    "#" )
      PARSE_METHOD="parse_hash"
      COMMENT_IN="NL"
      ;;
    " "|"\t" )
      PARSE_METHOD="parse_nl_space"
      ;;
    "\\" )
      PARSE_METHOD="parse_bs"
      ;;
    "'" )
      PARSE_METHOD="parse_sq"
      ;;
    '"' )
      PARSE_METHOD="parse_dq"
      ;;
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_nl"
      ;;
    * )
      PARSE_METHOD="parse_main"
      ;;
  esac
}

parse_nl() {
  case $1 in
    "#" )
      PARSE_METHOD="parse_hash"
      COMMENT_IN="NL"
      ;;
    " "|"\t" )
      PARSE_METHOD="parse_nl_space"
      ;;
    "\\" )
      PARSE_METHOD="parse_bs"
      ;;
    "'" )
      PARSE_METHOD="parse_sq"
      ;;
    '"' )
      PARSE_METHOD="parse_dq"
      ;;
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_nl"
      ;;
    * )
      PARSE_METHOD="parse_main"
      ;;
  esac
}

main() {
  local file=$1
  local line
  local char

  while IFS= read -r line; do
    while IFS= read -r -n 1 char; do
      $PARSE_METHOD "$char"
    done < <(echo $line)
  done < $file
}

main "$@"

###########################################################################################

. $_BASHTF_LIBEXEC_DIR/outputs

_bashtf_analyze_test_results() {
  local exitstat=$1
  local stdout=$(cat /tmp/_bashtf_command_stdout.$$.log)
  local errout=$(cat /tmp/_bashtf_command_stderr.$$.log)

  _bashtf_judge "$_BASHTF_TEST_COMMENT_CACHE" "$exitstat" "$stdout" "$stderr"

  #[ "$stdout" ] && {
  #  _bashtf_echo "[ stdout ]"
  #  _bashtf_echo "$stdout"
  #  : > "$_BASHTF_CMD_OUT"
  #}

  #[ "$errout" ] && {
  #  _bashtf_echo "[ errout ]"
  #  _bashtf_echo "$errout"
  #  : > "$_BASHTF_CMD_ERR"
  #}
}

_bashtf_judge() {
  local _testcmnt="$1" _exitstat="$2" _stdout="$3" _stderr="$4"
  local status __status=false match __match=false
  eval "$_testcmnt"

  if [ "$status" = "$_exitstat" ] || [ -z "$status" ] ; then
    __status=true
  fi

  if echo "$_stdout" | \egrep "$match" > /dev/null 2>&1 || [ -z "$match" ]; then
    __match=true
  fi

  _bashtf_echo "$__status $__match"
}

_bashtf_cache_execution_data() {
  local line="$1" testline

  _BASHTF_LINENO_CACHE="$line"
  _BASHTF_CMD_CACHE="$2"
  _BASHTF_CMD_EVAL_CACHE=$(eval "echo -n \"$2\"")

  if [ "${_BASHTF_TEST_COMMENT_STYLE[$line]}" = "EOL" ]; then
    testline="$line"
    _BASHTF_TEST_COMMENT_CACHE="${TEST_COMMENT[$testline]}"
    _BASHTF_TESTEXIST=true
  elif [ "${_BASHTF_TEST_COMMENT_STYLE[$((line+1))]}" = "NL" ]; then
    testline=$((line+1))
    _BASHTF_TEST_COMMENT_CACHE="${TEST_COMMENT[$testline]}"
    _BASHTF_TESTEXIST=true
  else
    _BASHTF_TESTEXIST=false
  fi
}

_bashtf_trap_command_execution() {
  local prev_cmd_stat="$?"
  local line="$1"
  local src_path="$2"
  [ "$src_path" = "$TARGET_FULLPATH" ] && {
    $_BASHTF_TESTEXIST && _bashtf_analyze_test_results "$prev_cmd_stat"
    _bashtf_cache_execution_data "$line" "$BASH_COMMAND"
    ((_BASHTF_CMD_ID++))
  }
}

_bashtf_runtest() {
  TARGET_FULLPATH="$(readlink -f -- "$1")"

  set -T
  exec 3>&1 4>&2 1> $_BASHTF_CMD_OUT 2> $_BASHTF_CMD_ERR
  trap '_bashtf_trap_command_execution "$LINENO" "$BASH_SOURCE"' DEBUG

  . "$TARGET_FULLPATH"
  _bashtf_analyze_test_results "$?" "$TARGET_FULLPATH"

  trap DEBUG
  exec 1>&3- 2>&4-
  set +T
}

_bashtf_runtest $1

rm "$_BASHTF_CMD_OUT" "$_BASHTF_CMD_ERR"
