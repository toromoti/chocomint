#!/usr/bin/env bash

declare _BASHTF_LIBEXEC_DIR="$(dirname -- "$(readlink -f -- "${BASH_SOURCE:-$0}")")"

declare -a _BASHTF_TEST_COMMENT_STYLE    # "NL" or "EOL"
declare -a TEST_COMMENT      # 行番号 -> テストコメントの内容
declare -i LINENUM=1
declare TEST_COMMENT
declare _BASHTF_TEST_MARKER=":"
declare PARSE_METHOD="parse_nl"

declare _BASHTF_CMD_OUT="/tmp/_bashtf_command_stdout.$$.log"
declare _BASHTF_CMD_ERR="/tmp/_bashtf_command_stderr.$$.log"

parse_test_comments() {
  case $1 in
    "$_BASHTF_TEST_MARKER" )
      PARSE_METHOD="parse_def_comments"
      ;;
    "" )
      _BASHTF_TEST_COMMENT_STYLE[LINENUM]="$COMMENT_IN"
      TEST_COMMENT[LINENUM]="$TEST_COMMENT"
      PARSE_METHOD="parse_nl"
      LINENUM+=1
      TEST_COMMENT=""
      ;;
    * )
      TEST_COMMENT="$TEST_COMMENT$1"
      ;;
  esac
}

parse_hash() {
  case $1 in
    "$_BASHTF_TEST_MARKER" )
      PARSE_METHOD="parse_test_comments"
      ;;
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_nl"
      ;;
    * )
      PARSE_METHOD="parse_main"
      ;;
  esac
}

parse_dq_bs() {
  case $1 in
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_dq"
      ;;
    * )
      PARSE_METHOD="parse_dq"
      ;;
  esac
}

parse_dq() {
  case $1 in
    "\\" )
      PARSE_METHOD="parse_dq_bs"
      ;;
    '"' )
      PARSE_METHOD="parse_main"
      ;;
    "" )
      LINENUM+=1
      ;;
    * )
      :
      ;;
  esac
}

parse_sq_bs() {
  case $1 in
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_sq"
      ;;
    * )
      PARSE_METHOD="parse_sq"
      ;;
  esac
}

parse_sq() {
  case $1 in
    "\\" )
      PARSE_METHOD="parse_sq_bs"
      ;;
    "'" )
      PARSE_METHOD="parse_main"
      ;;
    "" )
      LINENUM+=1
      ;;
    * )
      :
      ;;
  esac
}

parse_bs() {
  case $1 in
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_main"
      ;;
    * )
      PARSE_METHOD="parse_main"
      ;;
  esac
}

parse_main() {
  case $1 in
    "#" )
      PARSE_METHOD="parse_hash"
      COMMENT_IN="EOL"
      ;;
    "\\" )
      PARSE_METHOD="parse_bs"
      ;;
    "'" )
      PARSE_METHOD="parse_sq"
      ;;
    '"' )
      PARSE_METHOD="parse_dq"
      ;;
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_nl"
      ;;
    * )
      ;;
  esac
}

parse_nl_space() {
  case $1 in
    "#" )
      PARSE_METHOD="parse_hash"
      COMMENT_IN="NL"
      ;;
    " "|"\t" )
      PARSE_METHOD="parse_nl_space"
      ;;
    "\\" )
      PARSE_METHOD="parse_bs"
      ;;
    "'" )
      PARSE_METHOD="parse_sq"
      ;;
    '"' )
      PARSE_METHOD="parse_dq"
      ;;
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_nl"
      ;;
    * )
      PARSE_METHOD="parse_main"
      ;;
  esac
}

parse_nl() {
  case $1 in
    "#" )
      PARSE_METHOD="parse_hash"
      COMMENT_IN="NL"
      ;;
    " "|"\t" )
      PARSE_METHOD="parse_nl_space"
      ;;
    "\\" )
      PARSE_METHOD="parse_bs"
      ;;
    "'" )
      PARSE_METHOD="parse_sq"
      ;;
    '"' )
      PARSE_METHOD="parse_dq"
      ;;
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_nl"
      ;;
    * )
      PARSE_METHOD="parse_main"
      ;;
  esac
}

main() {
  local file=$1
  local line
  local char

  while IFS= read -r line; do
    while IFS= read -r -n 1 char; do
      $PARSE_METHOD "$char"
    done < <(echo $line)
  done < $file
}

main "$@"

###########################################################################################

. $_BASHTF_LIBEXEC_DIR/outputs


_bashtf_judge() {
  local _testcmnt="$1" _exitstat="$2" _stdout="$3" _stderr="$4"
  local status match
  local not_status not_match
  local -A v not_v
  local -a result_list

  eval "$_testcmnt"

  for var in ${!v[@]}; do
    if eval "[[ \$$var = \"${v[$var]}\" ]]"; then
      result_list+=( true )
    else
      result_list+=( false )
    fi
  done

  for var in ${!not_v[@]}; do
    if eval "[[ \$$var = \"${not_v[$var]}\" ]]"; then
      result_list+=( false )
    else
      result_list+=( true )
    fi
  done

  [ "$status" ] && if [[ "$status" = "$_exitstat" ]] ; then
    result_list+=( true )
  else
    result_list+=( false )
  fi

  [ "$not_status" ] && if [[ "$not_status" = "$_exitstat" ]] ; then
    result_list+=( false )
  else
    result_list+=( true )
  fi

  [ "$match" ] && if echo "$_stdout" | \egrep "$match" > /dev/null 2>&1; then
    result_list+=( true )
  else
    result_list+=( false )
  fi

  [ "$not_match" ] && if echo "$_stdout" | \egrep "$not_match" > /dev/null 2>&1; then
    result_list+=( false )
  else
    result_list+=( true )
  fi

  _bashtf_echo "===> ${result_list[@]}"
  _bashtf_indent_echo 5 "$_BASHTF_CMD_EVAL_CACHE"
}


_bashtf_analyze_test_results() {
  local exitstat=$1
  local stdout=$2
  local errout=$3

  #_bashtf_echo "--------- $_BASHTF_TEST_COMMENT_EVAL_CACHE"
  _bashtf_judge "$_BASHTF_TEST_COMMENT_CACHE" "$exitstat" "$stdout" "$stderr"

  [ "$stdout" ] && {
  :
  #  _bashtf_echo "[ stdout ]"
  #  _bashtf_echo "$stdout"
  }

  [ "$errout" ] && {
  :
  #  _bashtf_echo "[ errout ]"
  #  _bashtf_echo "$errout"
  }
}


_bashtf_cache_execution_data() {
  local line="$1" testline

  _BASHTF_LINENO_CACHE="$line"
  _BASHTF_CMD_CACHE="$2"
  _BASHTF_CMD_EVAL_CACHE=$(eval "echo -n \"$2\"")

  if [ "${_BASHTF_TEST_COMMENT_STYLE[$line]}" = "EOL" ]; then
    testline="$line"
    _BASHTF_TEST_COMMENT_CACHE="${TEST_COMMENT[$testline]}"
    _BASHTF_TEST_COMMENT_EVAL_CACHE=$(eval "echo -n \"${TEST_COMMENT[$testline]}\"")
    _BASHTF_TESTEXIST=true
  elif [ "${_BASHTF_TEST_COMMENT_STYLE[$((line+1))]}" = "NL" ]; then
    testline=$((line+1))
    _BASHTF_TEST_COMMENT_CACHE="${TEST_COMMENT[$testline]}"
    _BASHTF_TEST_COMMENT_EVAL_CACHE=$(eval "echo -n \"${TEST_COMMENT[$testline]}\"")
    _BASHTF_TESTEXIST=true
  else
    _BASHTF_TEST_COMMENT_CACHE=''
    _BASHTF_TESTEXIST=false
  fi
}


_bashtf_trap_command_execution() {
  local prev_stat="$?"

  #exec 1>&-
  local prev_stdout=$(<$_BASHTF_CMD_OUT)
  #exec 1> "$_BASHTF_CMD_OUT"
  : > "$_BASHTF_CMD_OUT"

  exec 2>&-
  local prev_errout=$(<$_BASHTF_CMD_ERR)
  exec 2> "$_BASHTF_CMD_ERR"

  local line="$1"
  local src_path="$2"

  [ "$src_path" = "$TARGET_FULLPATH" ] && {
    _BASHTF_TESTEXIST=${_BASHTF_TESTEXIST:-false} # false when start
    $_BASHTF_TESTEXIST && _bashtf_analyze_test_results "$prev_stat" "$prev_stdout" "$prev_stderr"
    _bashtf_cache_execution_data "$line" "$BASH_COMMAND"
  }
}


_bashtf_runtest() {
  TARGET_FULLPATH="$(readlink -f -- "$1")"

  set -T
  exec 3>&1 4>&2 1> $_BASHTF_CMD_OUT 2> $_BASHTF_CMD_ERR
  trap '_bashtf_trap_command_execution "$LINENO" "$BASH_SOURCE"' DEBUG

  . "$TARGET_FULLPATH"
  _bashtf_analyze_test_results "$?" "$TARGET_FULLPATH"

  trap DEBUG
  exec 1>&3- 2>&4-
  set +T
}


_bashtf_runtest $1


rm "$_BASHTF_CMD_OUT" "$_BASHTF_CMD_ERR"
