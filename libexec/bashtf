#!/usr/bin/env bash

_BASHTF_LIBEXEC_DIR="$(dirname -- "$(readlink -f -- "${BASH_SOURCE:-$0}")")"

_BASHTF_CMD_OUT="/tmp/_bashtf_command_stdout.$$.log"
_BASHTF_CMD_ERR="/tmp/_bashtf_command_stderr.$$.log"

_bashtf_ok() {
  _bashtf_echo -n " ✔ ok "
  _bashtf_echo " $@"
}

_bashtf_ng() {
  _bashtf_echo -n " ✘ ng "
  _bashtf_echo " $@"
}

_bashtf_judge() {
  # $1 left string
  # $2 middle string
  # $3 right string
  # $4 exit status
  # $5 stdout
  # $6 stderr
  case $2 in
    "=" )
      if eval [ "$1" = "$3" ]; then
        _bashtf_ok "$1 $2 $3"
      else
        _bashtf_ng "$1 $2 $3"
      fi
      ;;
    "!=" )
      if [ "$1" != "$3" ]; then
        _bashtf_ok "$1 $2 $3"
      else
        _bashtf_ng "$1 $2 $3"
      fi
      ;;
    ":" )
      case $1 in
        'status' )
          if [ "$4" = "$3" ]; then
            _bashtf_ok "$1 $2 $3"
          else
            _bashtf_ng "$1 $2 $3"
          fi
          ;;
        'match' )
          if \egrep -q "`eval echo "$3"`" "$_BASHTF_CMD_OUT"; then
            _bashtf_ok "$1 $2 $3"
          else
            _bashtf_ng "$1 $2 $3"
          fi
          ;;
      esac
      ;;
    "!:" )
      case $1 in
        'status' )
          if [ "$4" != "$3" ]; then
            _bashtf_ok "$1 $2 $3"
          else
            _bashtf_ng "$1 $2 $3"
          fi
          ;;
        'match' )
          if \egrep -q "`eval echo "$3"`" "$_BASHTF_CMD_OUT"; then
            _bashtf_ng "$1 $2 $3"
          else
            _bashtf_ok "$1 $2 $3"
          fi
          ;;
      esac
      ;;
  esac
}


_bashtf_analyze_test_results() {
  # $1 exitstatus
  # $2 stdout
  # $3 stderr
  _bashtf_echo "==> $_BASHTF_CMD_CACHE"
  for _bashtf_i in `seq 0 ${_BASHTF_HASH[$_BASHTF_TESTLINE,max]}`
  do
    _bashtf_judge \
      "${_BASHTF_HASH[$_BASHTF_TESTLINE,$_bashtf_i,left]}" \
      "${_BASHTF_HASH[$_BASHTF_TESTLINE,$_bashtf_i,mid]}" \
      "${_BASHTF_HASH[$_BASHTF_TESTLINE,$_bashtf_i,right]}" \
      "$1" \
      "$2" \
      "$3"
  done
  _bashtf_echo
}


_bashtf_cache_execution_data() {
  _BASHTF_LINENO_CACHE="$1"
  _BASHTF_CMD_CACHE="$2"
  _BASHTF_CMD_EVAL_CACHE=$(eval "echo -n \"$2\"")

  if [ "${_BASHTF_TEST_COMMENT_STYLE[$1]}" = "EOL" ]; then
    _BASHTF_TESTLINE="$1"
    _BASHTF_TESTEXIST=true
    : > $_BASHTF_CMD_OUT
    : > $_BASHTF_CMD_ERR
  elif [ "${_BASHTF_TEST_COMMENT_STYLE[$(($1+1))]}" = "NL" ]; then
    _BASHTF_TESTLINE=$(($1+1))
    _BASHTF_TESTEXIST=true
    : > $_BASHTF_CMD_OUT
    : > $_BASHTF_CMD_ERR
  else
    _BASHTF_TESTEXIST=false
  fi
}


_bashtf_trap() {
  # $1 line number
  # $2 source path
  local _bashtf_prev_stat="$?"

  if [ "$2" = "$TARGET_FULLPATH" ]; then
    $_BASHTF_TESTEXIST && {
      _bashtf_analyze_test_results \
        "$_bashtf_prev_stat" \
        "$(<$_BASHTF_CMD_OUT)" \
        "$(<$_BASHTF_CMD_ERR)"
    }
    _bashtf_cache_execution_data "$1" "$BASH_COMMAND"
  fi
}


_bashtf_redirect_switch_on() {
  exec 3>&1 4>&2 1> $_BASHTF_CMD_OUT 2> $_BASHTF_CMD_ERR
}


_bashtf_redirect_switch_off() {
  exec 1>&3- 2>&4-
}


_bashtf_test_process() {
  _BASHTF_FAIL_COUNT=0
  _BASHTF_TEST_COUNT=0
  _BASHTF_TESTEXIST=false
  _bashtf_redirect_switch_on

  source "$1"; local exitstat=$?
  # if the last command has a test, execute the analysis here.
  $_BASHTF_TESTEXIST && {
    _bashtf_analyze_test_results \
      "$exitstat" \
      "$(<$_BASHTF_CMD_OUT)" \
      "$(<$_BASHTF_CMD_ERR)"
  }

  _bashtf_redirect_switch_off

  rm "$_BASHTF_CMD_OUT" "$_BASHTF_CMD_ERR"
}


_bashtf_main() {
  TARGET_FULLPATH="$(readlink -f -- "$1")"
  eval "`$_BASHTF_LIBEXEC_DIR/parse $TARGET_FULLPATH`"
  source $_BASHTF_LIBEXEC_DIR/outputs

  set -T; trap '_bashtf_trap "$LINENO" "$BASH_SOURCE"' DEBUG

  _bashtf_test_process "$TARGET_FULLPATH"

  trap DEBUG; set +T
}


_bashtf_main "$1"
