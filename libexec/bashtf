#!/usr/bin/env bash

declare _BASHTF_LIBEXEC_DIR="$(dirname -- "$(readlink -f -- "${BASH_SOURCE:-$0}")")"

declare _BASHTF_CMD_OUT="/tmp/_bashtf_command_stdout.$$.log"
declare _BASHTF_CMD_ERR="/tmp/_bashtf_command_stderr.$$.log"

eval $($_BASHTF_LIBEXEC_DIR/parse "$@")

. $_BASHTF_LIBEXEC_DIR/outputs

_bashtf_judge() {
  local _testcmnt="$1" _exitstat="$2" _stdout="$3" _stderr="$4"
  local status match
  local not_status not_match
  local -A v not_v
  local -a result_list

  eval "$_testcmnt"

  for var in ${!v[@]}; do
    if eval "[[ \$$var = \"${v[$var]}\" ]]"; then
      result_list+=( true )
    else
      result_list+=( false )
    fi
  done

  for var in ${!not_v[@]}; do
    if eval "[[ \$$var = \"${not_v[$var]}\" ]]"; then
      result_list+=( false )
    else
      result_list+=( true )
    fi
  done

  [ "$status" ] && if [[ "$status" = "$_exitstat" ]] ; then
    result_list+=( true )
  else
    result_list+=( false )
  fi

  [ "$not_status" ] && if [[ "$not_status" = "$_exitstat" ]] ; then
    result_list+=( false )
  else
    result_list+=( true )
  fi

  [ "$match" ] && if echo "$_stdout" | \egrep "$match" > /dev/null 2>&1; then
    result_list+=( true )
  else
    result_list+=( false )
  fi

  [ "$not_match" ] && if echo "$_stdout" | \egrep "$not_match" > /dev/null 2>&1; then
    result_list+=( false )
  else
    result_list+=( true )
  fi

  _bashtf_echo "===> ${result_list[@]}"
  _bashtf_indent_echo 5 "$_BASHTF_CMD_EVAL_CACHE"
}


_bashtf_analyze_test_results() {
  local exitstat=$1
  local stdout=$2
  local errout=$3

  #_bashtf_echo "--------- $_BASHTF_TEST_COMMENT_EVAL_CACHE"
  _bashtf_judge "$_BASHTF_TEST_COMMENT_CACHE" "$exitstat" "$stdout" "$stderr"

  [ "$stdout" ] && {
  :
  #  _bashtf_echo "[ stdout ]"
  #  _bashtf_echo "$stdout"
  }

  [ "$errout" ] && {
  :
  #  _bashtf_echo "[ errout ]"
  #  _bashtf_echo "$errout"
  }
}


_bashtf_cache_execution_data() {
  local line="$1" testline

  _BASHTF_LINENO_CACHE="$line"
  _BASHTF_CMD_CACHE="$2"
  _BASHTF_CMD_EVAL_CACHE=$(eval "echo -n \"$2\"")

  if [ "${_BASHTF_TEST_COMMENT_STYLE[$line]}" = "EOL" ]; then
    testline="$line"
    _BASHTF_TEST_COMMENT_CACHE="${_BASHTF_TEST_COMMENT_LIST[$testline]}"
    _BASHTF_TEST_COMMENT_EVAL_CACHE=$(eval "echo -n \"${_BASHTF_TEST_COMMENT_LIST[$testline]}\"")
    _BASHTF_TESTEXIST=true
  elif [ "${_BASHTF_TEST_COMMENT_STYLE[$((line+1))]}" = "NL" ]; then
    testline=$((line+1))
    _BASHTF_TEST_COMMENT_CACHE="${_BASHTF_TEST_COMMENT_LIST[$testline]}"
    _BASHTF_TEST_COMMENT_EVAL_CACHE=$(eval "echo -n \"${_BASHTF_TEST_COMMENT_LIST[$testline]}\"")
    _BASHTF_TESTEXIST=true
  else
    _BASHTF_TEST_COMMENT_CACHE=''
    _BASHTF_TESTEXIST=false
  fi
}


_bashtf_trap_command_execution() {
  local prev_stat="$?"

  #exec 1>&-
  local prev_stdout=$(<$_BASHTF_CMD_OUT)
  #exec 1> "$_BASHTF_CMD_OUT"
  : > "$_BASHTF_CMD_OUT"

  exec 2>&-
  local prev_errout=$(<$_BASHTF_CMD_ERR)
  exec 2> "$_BASHTF_CMD_ERR"

  local line="$1"
  local src_path="$2"

  [ "$src_path" = "$TARGET_FULLPATH" ] && {
    _BASHTF_TESTEXIST=${_BASHTF_TESTEXIST:-false} # false when start
    $_BASHTF_TESTEXIST && _bashtf_analyze_test_results "$prev_stat" "$prev_stdout" "$prev_stderr"
    _bashtf_cache_execution_data "$line" "$BASH_COMMAND"
  }
}


_bashtf_runtest() {
  TARGET_FULLPATH="$(readlink -f -- "$1")"

  set -T
  exec 3>&1 4>&2 1> $_BASHTF_CMD_OUT 2> $_BASHTF_CMD_ERR
  trap '_bashtf_trap_command_execution "$LINENO" "$BASH_SOURCE"' DEBUG

  . "$TARGET_FULLPATH"
  _bashtf_analyze_test_results "$?" "$TARGET_FULLPATH"

  trap DEBUG
  exec 1>&3- 2>&4-
  set +T
}


_bashtf_runtest $1


rm "$_BASHTF_CMD_OUT" "$_BASHTF_CMD_ERR"
