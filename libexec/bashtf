#!/usr/bin/env bash

#set -x # debug mode
#set -n # syntax check
ROOT="$(dirname -- "$(readlink -f -- "${BASH_SOURCE:-$0}")")"/..
echo $ROOT

declare -a DEF_COMMENT_LINENUM   # テストコメントがある行番号
declare -a TEST_COMMENT_LINENUM  # テストコメントがある行番号
declare -a _BASHTF_TEST_COMMENT_STYLE    # "NL" or "EOL"
declare -a TEST_COMMENT      # 行番号 -> テストコメントの内容
declare -i LINENUM=1
declare TEST_COMMENT
declare _BASHTF_TEST_MARKER=":"
declare PARSE_METHOD="parse_nl"

parse_def_comments() {
  case $1 in
    "" )
      DEF_COMMENT_LINENUM+=( "$LINENUM" )
      PARSE_METHOD="parse_nl"
      LINENUM+=1
      DEF_COMMENT=""
      ;;
    * )
      DEF_COMMENT="$DEF_COMMENT$1"
      ;;
  esac
}

parse_test_comments() {
  case $1 in
    "$_BASHTF_TEST_MARKER" )
      PARSE_METHOD="parse_def_comments"
      ;;
    "" )
      TEST_COMMENT_LINENUM+=( "$LINENUM" )
      _BASHTF_TEST_COMMENT_STYLE[LINENUM]="$COMMENT_IN"
      TEST_COMMENT[LINENUM]="$TEST_COMMENT"
      PARSE_METHOD="parse_nl"
      LINENUM+=1
      TEST_COMMENT=""
      ;;
    * )
      TEST_COMMENT="$TEST_COMMENT$1"
      ;;
  esac
}

parse_hash() {
  case $1 in
    "$_BASHTF_TEST_MARKER" )
      PARSE_METHOD="parse_test_comments"
      ;;
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_nl"
      ;;
    * )
      PARSE_METHOD="parse_main"
      ;;
  esac
}

parse_dq_bs() {
  case $1 in
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_dq"
      ;;
    * )
      PARSE_METHOD="parse_dq"
      ;;
  esac
}

parse_dq() {
  case $1 in
    "\\" )
      PARSE_METHOD="parse_dq_bs"
      ;;
    '"' )
      PARSE_METHOD="parse_main"
      ;;
    "" )
      LINENUM+=1
      ;;
    * )
      :
      ;;
  esac
}

parse_sq_bs() {
  case $1 in
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_sq"
      ;;
    * )
      PARSE_METHOD="parse_sq"
      ;;
  esac
}

parse_sq() {
  case $1 in
    "\\" )
      PARSE_METHOD="parse_sq_bs"
      ;;
    "'" )
      PARSE_METHOD="parse_main"
      ;;
    "" )
      LINENUM+=1
      ;;
    * )
      :
      ;;
  esac
}

parse_bs() {
  case $1 in
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_main"
      ;;
    * )
      PARSE_METHOD="parse_main"
      ;;
  esac
}

parse_main() {
  case $1 in
    "#" )
      PARSE_METHOD="parse_hash"
      COMMENT_IN="EOL"
      ;;
    "\\" )
      PARSE_METHOD="parse_bs"
      ;;
    "'" )
      PARSE_METHOD="parse_sq"
      ;;
    '"' )
      PARSE_METHOD="parse_dq"
      ;;
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_nl"
      ;;
    * )
      ;;
  esac
}

parse_nl_space() {
  case $1 in
    "#" )
      PARSE_METHOD="parse_hash"
      COMMENT_IN="NL"
      ;;
    " "|"\t" )
      PARSE_METHOD="parse_nl_space"
      ;;
    "\\" )
      PARSE_METHOD="parse_bs"
      ;;
    "'" )
      PARSE_METHOD="parse_sq"
      ;;
    '"' )
      PARSE_METHOD="parse_dq"
      ;;
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_nl"
      ;;
    * )
      PARSE_METHOD="parse_main"
      ;;
  esac
}

parse_nl() {
  case $1 in
    "#" )
      PARSE_METHOD="parse_hash"
      COMMENT_IN="NL"
      ;;
    " "|"\t" )
      PARSE_METHOD="parse_nl_space"
      ;;
    "\\" )
      PARSE_METHOD="parse_bs"
      ;;
    "'" )
      PARSE_METHOD="parse_sq"
      ;;
    '"' )
      PARSE_METHOD="parse_dq"
      ;;
    "" )
      LINENUM+=1
      PARSE_METHOD="parse_nl"
      ;;
    * )
      PARSE_METHOD="parse_main"
      ;;
  esac
}

main() {
  local file=$1
  local line
  local char

  while IFS= read -r line; do
    while IFS= read -r -n 1 char; do
      $PARSE_METHOD "$char"
    done < <(echo $line)
  done < $file
}

main "$@"

declare -p TEST_COMMENT
echo ------------
declare -p TEST_COMMENT_LINENUM
echo ------------
declare -p _BASHTF_TEST_COMMENT_STYLE
echo ------------
declare -p BASH_SOURCE

declare -i _BASHTF_CMD_ID=0

_bashtf_echo() {
  echo "$@" >&3
}

_bashtf_eval_echo() {
  eval "_bashtf_echo $@"
}

_bashtf_tput() {
  tput $@ >&3
}

_bashtf_draw_ruler() {
  [ "$TERM_COLS" ] || {
    local cols=`tput cols 2>&4`
    for ((i=0; i<$cols; i++))
    do
      TERM_COLS="$TERM_COLS""$1"
    done
  }
  _bashtf_echo "$TERM_COLS"
}

_bashtf_prev_result() {
  local cmd_stat=$1
  local stdout=$(cat /tmp/_bashtf_command_stdout.$$.log)
  local errout=$(cat /tmp/_bashtf_command_stderr.$$.log)

  [ "$stdout" ] && {
    _bashtf_echo "[ stdout ]"
    _bashtf_echo "$stdout"
    : > "$_BASHTF_CMD_OUT"
  }

  [ "$errout" ] && {
    _bashtf_echo "[ errout ]"
    _bashtf_echo "$errout"
    : > "$_BASHTF_CMD_ERR"
  }
}

moja() {
  local status
  local match
  eval "$@"
  _bashtf_echo "-- status -> $status"
  _bashtf_echo "-- match -> '$match'"
}

_bashtf_test_process() {
  local line="$1"
  local testline

  if [ "${_BASHTF_TEST_COMMENT_STYLE[$line]}" = "EOL" ]; then
    testline="$line"
  elif [ "${_BASHTF_TEST_COMMENT_STYLE[$((line+1))]}" = "NL" ]; then
    testline=$((line+1))
  fi

  _BASHTF_TEST_COMMENT_CACHE="${TEST_COMMENT[$testline]}"
}

catch_execution() {
  local prev_cmd_stat="$?"
  local line="$1"
  local src_path="$2"
  [ "$src_path" = "$TARGET_FULLPATH" ] && {
    [ $((_BASHTF_CMD_ID++)) -gt 0 ] && _bashtf_prev_result "$prev_cmd_stat"

    _bashtf_tput bold
    _bashtf_draw_ruler "="
    _bashtf_echo      "No.$_BASHTF_CMD_ID  L$line"
    _bashtf_echo      "raw  : $BASH_COMMAND"
    _bashtf_eval_echo "eval : $BASH_COMMAND"
    _bashtf_test_process "$line"
    _bashtf_tput sgr0
  }
}

_BASHTF_CMD_OUT="/tmp/_bashtf_command_stdout.$$.log"
_BASHTF_CMD_ERR="/tmp/_bashtf_command_stderr.$$.log"

_bashtf_runtest() {
  TARGET_FULLPATH="$(readlink -f -- "$1")"

  set -T
  exec 3>&1 4>&2 1> $_BASHTF_CMD_OUT 2> $_BASHTF_CMD_ERR
  trap 'catch_execution "$LINENO" "$BASH_SOURCE"' DEBUG

  . "$TARGET_FULLPATH"
  _bashtf_prev_result "$?" "$TARGET_FULLPATH"

  trap DEBUG
  exec 1>&3- 2>&4-
  set +T
}

_bashtf_runtest $1

rm "$_BASHTF_CMD_OUT" "$_BASHTF_CMD_ERR"
